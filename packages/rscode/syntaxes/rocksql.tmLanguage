<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>fileTypes</key>
    <array>
      <string>sql</string>
      <string>rsql</string>
    </array>
    <key>foldingStartMarker</key>
    <string>\s*\(\s*$</string>
    <key>foldingStopMarker</key>
    <string>^\s*\)</string>
    <key>keyEquivalent</key>
    <string>^~S</string>
    <key>name</key>
    <string>MySQL</string>
    <key>patterns</key>
    <array>
      <dict>
        <key>include</key>
        <string>#comments</string>
      </dict>
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
          <key>2</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
          <key>3</key>
          <dict>
            <key>name</key>
            <string>constant.numeric.sql</string>
          </dict>
          <key>4</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
          <key>5</key>
          <dict>
            <key>name</key>
            <string>constant.numeric.sql</string>
          </dict>
          <key>6</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
          <key>7</key>
          <dict>
            <key>name</key>
            <string>constant.numeric.sql</string>
          </dict>
          <key>8</key>
          <dict>
            <key>name</key>
            <string>constant.numeric.sql</string>
          </dict>
          <key>9</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
          <key>10</key>
          <dict>
            <key>name</key>
            <string>constant.numeric.sql</string>
          </dict>
          <key>11</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
          <key>12</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
          <key>13</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
          <key>14</key>
          <dict>
            <key>name</key>
            <string>constant.numeric.sql</string>
          </dict>
          <key>15</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
        </dict>
        <key>match</key>
        <string>(?xi)
         
        # normal stuff, capture 1
         \b(bigint|bigserial|bit|boolean|box|bytea|cidr|circle|date|double\sprecision|inet|int|integer|line|lseg|macaddr|money|oid|path|point|polygon|real|serial|smallint|sysdate|text)\b

        # numeric suffix, capture 2 + 3i
        |\b(bit\svarying|character\s(?:varying)?|tinyint|var\schar|float|interval)\((\d+)\)

        # optional numeric suffix, capture 4 + 5i
        |\b(char|number|varchar\d?)\b(?:\((\d+)\))?

        # special case, capture 6 + 7i + 8i
        |\b(numeric)\b(?:\((\d+),(\d+)\))?

        # special case, captures 9, 10i, 11
        |\b(times)(?:\((\d+)\))(\swithoutstimeszone\b)?

        # special case, captures 12, 13, 14i, 15
        |\b(timestamp)(?:(s)\((\d+)\)(\swithoutstimeszone\b)?)?

      </string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i:\b((?:primary|foreign)\s+key|references|on\sdelete(\s+cascade)?|check|constraint)\b)</string>
        <key>name</key>
        <string>storage.modifier.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>\b\d+\b</string>
        <key>name</key>
        <string>constant.numeric.sql</string>
      </dict>
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>keyword.other.sql</string>
          </dict>
          <key>2</key>
          <dict>
            <key>name</key>
            <string>variable.other.member</string>
          </dict>
          <key>3</key>
          <dict>
            <key>name</key>
            <string>keyword.other.DML.sql</string>
          </dict>
          <key>4</key>
          <dict>
            <key>name</key>
            <string>variable.other.member</string>
          </dict>
        </dict>
        <key>match</key>
        <string>(?i:^\s*(select)\s+(.*)\s+(into)\s+((?:\w+)(?:\,\s+)?)+)</string>
        <key>name</key>
        <string>meta.create.sql
"1":
  name: keyword.other.DML.sql
"2":
  name: constant.other.database-name.sql
"3":
  name: constant.other.table-name.sql
"4":
  name: keyword.other.alias.sql
"5":
  name: constant.other.database-name.sql</string>
      </dict>
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>constant.other.database-name.sql</string>
          </dict>
          <key>2</key>
          <dict>
            <key>name</key>
            <string>constant.other.table-name.sql</string>
          </dict>
          <key>3</key>
          <dict>
            <key>name</key>
            <string>keyword.other.alias.sql</string>
          </dict>
        </dict>
        <key>match</key>
        <string>(?i)(\w+\.)?(\S+?)\s+(AS)\s+([\w'"`]+)</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i:\b(select(\s+distinct)?|insert\s+(ignore\s+)?into|update|delete|from|set|where|group\sby|or|like|and|union(\s+all)?|having|order\sby|limit|(inner|cross)\s+join|straight_join|(left|right)(\s+outer)?\s+join|natural(\s+(left|right)(\s+outer)?)?\s+join)\b)</string>
        <key>name</key>
        <string>keyword.other.DML.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i:\b(ALL|AND|AS|ASC|BERNOULLI|BETWEEN|CASE|CROSS|CUBE|DESC|DESCRIBE|DISTINCT|ELSE|END|EXCEPT|EXISTS|FROM|GROUP BY|GROUPING SETS|HAVING|IN|INNER|INSERT INTO|INTERSECT|IS DISTINCT FROM|IS NULL|JOIN|LEFT|LIKE|LIMIT|NOT|ON|OR|ORDER BY|OUTER|RIGHT|ROLLUP|SELECT|TABLESAMPLE|THEN|UNION|UNNEST|USING|WHEN|WHERE|WITH)\b)</string>
        <key>name</key>
        <string>keyword.other.DML.sql.rockset</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i:\b(on|((is\s+)?not\s+)?null)\b)</string>
        <key>name</key>
        <string>keyword.other.DDL.create.II.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i:\bvalues\b)</string>
        <key>name</key>
        <string>keyword.other.DML.II.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i)\b(DESC|ASC)\b</string>
        <key>name</key>
        <string>keyword.other.order.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>\*</string>
        <key>name</key>
        <string>keyword.operator.star.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>[!&lt;&gt;]?=|&lt;&gt;|&lt;|&gt;|NOT IN|\bIN\b|BETWEEN|!=|&lt;=|=&gt;|\bIS\b|IS NOT</string>
        <key>name</key>
        <string>keyword.operator.comparison.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>-|\+|/</string>
        <key>name</key>
        <string>keyword.operator.math.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>\|\|</string>
        <key>name</key>
        <string>keyword.operator.concatenator.sql</string>
      </dict>
      <dict>
        <key>comment</key>
        <string>All functions and operators in MySQL 5.7</string>
        <key>match</key>
        <string>(?i)\b(CAST|IS_SCALAR|STATIC_CAST|TRY_CAST|TRY_STATIC_CAST|TYPEOF|HASH|MD5|SHA1|SHA256|SHA512|HMAC_MD5|HMAC_SHA1|HMAC_SHA256|HMAC_SHA512|HMAC|OBJECT|ZIP|ELEMENT_AT|LENGTH|KEYS|VALUES|ITEMS|MERGE|ERASE|CONCAT|LENGTH|LOWER|LTRIM|NORMALIZE|UPPER|REPLACE|RTRIM|SPLIT|STRPOS|SUBSTR|TRIM|FROM_HEX|FROM_UTF8|TO_HEX|TO_UTF8|REGEXP_EXTRACT|REGEXP_EXTRACT_ALL|REGEXP_LIKE|REGEXP_REPLACE|REGEXP_SPLIT|APPROX_DISTINCT|ARBITRARY|ARRAY_AGG|COUNT|COUNT|GROUPING|BITWISE_AND_AGG|BITWISE_OR_AGG|BOOL_AND|BOOL_OR|COUNT_IF|EVERY|AVG|GEOMETRIC_MEAN|MAX|MAX_BY|MIN|MIN_BY|STDDEV_SAMP|SUM|BOOST|CONTAINS|HAS_TERM|PROXIMITY|PROXIMITY_BOOST|SEARCH|TOKENIZE|ABS|CEIL|CEILING|GREATEST|LEAST|SIGN|FLOOR|EXP|POW|POWER|SQRT|LN|LOG10|LOG2|ACOS|ACOSH|ASIN|ASINH|ATAN|ATAN2|ATANH|COS|COSH|HYPOT|SIN|SINH|TAN|TANH|BIT_COUNT|BITWISE_NOT|BITWISE_XOR|COALESCE|IF|ARRAY_CREATE|ARRAY_POSITION|ARRAY_LAST_POSITION|LENGTH|SLICE|ARRAY_DISTINCT|CURRENT_DATE|CURRENT_DATETIME|CURRENT_TIME|CURRENT_TIMESTAMP|EXTRACT|FORMAT_ISO8601|FORMAT_ISO8601|DATE|DATE|DATE|FORMAT_DATE|PARSE_DATE|PARSE_DATE_ISO8601|FORMAT_TIME|PARSE_TIME|PARSE_TIME_ISO8601|TIME|TIME|TIME|DATETIME|DATETIME|DATETIME|FORMAT_DATETIME|PARSE_DATETIME|PARSE_DATETIME_ISO8601|FORMAT_TIMESTAMP|PARSE_TIMESTAMP|PARSE_TIMESTAMP_ISO8601|TIME_BUCKET|TIMESTAMP_MICROS|TIMESTAMP_MILLIS|TIMESTAMP_SECONDS|UNIX_MICROS|UNIX_MILLIS|UNIX_SECONDS|MICROSECONDS|MILLISECONDS|SECONDS|MINUTES|HOURS|DAYS|MONTHS|YEARS|PARSE_DURATION_SECONDS|PARSE_DURATION_MONTHS|DURATION_MICROS|DURATION_MILLIS|DURATION_SECONDS|DURATION_MONTHS)\b</string>
        <key>name</key>
        <string>support.function.sql</string>
      </dict>
      <dict>
        <key>comment</key>
        <string>List of SQL99 built-in functions from http://www.oreilly.com/catalog/sqlnut/chapter/ch04.html</string>
        <key>match</key>
        <string>(?i)\b(CURRENT_(DATE|TIME(STAMP)?|USER)|(SESSION|SYSTEM)_USER)\b</string>
        <key>name</key>
        <string>support.function.scalar.sql</string>
      </dict>
      <dict>
        <key>comment</key>
        <string>List of SQL99 built-in functions from http://www.oreilly.com/catalog/sqlnut/chapter/ch04.html</string>
        <key>match</key>
        <string>(?i)\b(AVG|COUNT|MIN|MAX|SUM)(?=\s*\()</string>
        <key>name</key>
        <string>support.function.aggregate.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i)\b(DELIMITER|CONCATENATE|CONVERT|LOWER|SUBSTRING|TRANSLATE|TRIM|UPPER)\b</string>
        <key>name</key>
        <string>support.function.string.sql</string>
      </dict>
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>constant.other.database-name.sql</string>
          </dict>
          <key>2</key>
          <dict>
            <key>name</key>
            <string>constant.other.table-name.sql</string>
          </dict>
        </dict>
        <key>match</key>
        <string>\b(\w+?)\.(\w+)\b</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i:(@[^\s]+))</string>
        <key>name</key>
        <string>variable.other.sql</string>
      </dict>
      <dict>
        <key>include</key>
        <string>#strings</string>
      </dict>
      <dict>
        <key>include</key>
        <string>#regexps</string>
      </dict>
      <dict>
        <key>include</key>
        <string>#parameters</string>
      </dict>
    </array>
    <key>repository</key>
    <dict>
      <key>comments</key>
      <dict>
        <key>patterns</key>
        <array>
          <dict>
            <key>captures</key>
            <dict>
              <key>1</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.comment.sql</string>
              </dict>
            </dict>
            <key>match</key>
            <string>(--).*$\n?</string>
            <key>name</key>
            <string>comment.line.double-dash.sql</string>
          </dict>
          <dict>
            <key>begin</key>
            <string>/\*</string>
            <key>captures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.comment.sql</string>
              </dict>
            </dict>
            <key>end</key>
            <string>\*/</string>
            <key>name</key>
            <string>comment</string>
          </dict>
        </array>
      </dict>
      <key>regexps</key>
      <dict>
        <key>patterns</key>
        <array>
          <dict>
            <key>begin</key>
            <string>/(?=\S.*/)</string>
            <key>beginCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
            </dict>
            <key>end</key>
            <string>/</string>
            <key>endCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>name</key>
            <string>string.regexp.sql</string>
            <key>patterns</key>
            <array>
              <dict>
                <key>include</key>
                <string>#string_interpolation</string>
              </dict>
              <dict>
                <key>match</key>
                <string>\\/</string>
                <key>name</key>
                <string>constant.character.escape.slash.sql</string>
              </dict>
            </array>
          </dict>
          <dict>
            <key>begin</key>
            <string>%r\{</string>
            <key>beginCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
            </dict>
            <key>comment</key>
            <string>We should probably handle nested bracket pairs!?! -- Allan</string>
            <key>end</key>
            <string>\}</string>
            <key>endCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>name</key>
            <string>string.regexp.modr.sql</string>
            <key>patterns</key>
            <array>
              <dict>
                <key>include</key>
                <string>#string_interpolation</string>
              </dict>
            </array>
          </dict>
        </array>
      </dict>
      <key>string_escape</key>
      <dict>
        <key>match</key>
        <string>\\.</string>
        <key>name</key>
        <string>constant.character.escape.sql</string>
      </dict>
      <key>parameters</key>
      <dict>
        <key>match</key>
        <string>\s:\S+\s</string>
        <key>name</key>
        <string>variable.parameters.sql</string>
      </dict>
      <key>string_interpolation</key>
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>punctuation.definition.string.end.sql</string>
          </dict>
        </dict>
        <key>match</key>
        <string>(#\{)([^\}]*)(\})</string>
        <key>name</key>
        <string>string.interpolated.sql</string>
      </dict>
      <key>strings</key>
      <dict>
        <key>patterns</key>
        <array>
          <dict>
            <key>captures</key>
            <dict>
              <key>1</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
              <key>3</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>comment</key>
            <string>this is faster than the next begin/end rule since sub-pattern will match till end-of-line and SQL files tend to have very long lines.</string>
            <key>match</key>
            <string>(')[^'\\]*(')</string>
            <key>name</key>
            <string>string.quoted.single.sql</string>
          </dict>
          <dict>
            <key>begin</key>
            <string>'</string>
            <key>beginCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
            </dict>
            <key>end</key>
            <string>'</string>
            <key>endCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>name</key>
            <string>string.quoted.single.sql</string>
            <key>patterns</key>
            <array>
              <dict>
                <key>include</key>
                <string>#string_escape</string>
              </dict>
            </array>
          </dict>
          <dict>
            <key>captures</key>
            <dict>
              <key>1</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
              <key>3</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>comment</key>
            <string>this is faster than the next begin/end rule since sub-pattern will match till end-of-line and SQL files tend to have very long lines.</string>
            <key>match</key>
            <string>(`)[^`\\]*(`)</string>
            <key>name</key>
            <string>string.quoted.other.backtick.sql</string>
          </dict>
          <dict>
            <key>begin</key>
            <string>`</string>
            <key>beginCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
            </dict>
            <key>end</key>
            <string>`</string>
            <key>endCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>name</key>
            <string>string.quoted.other.backtick.sql</string>
            <key>patterns</key>
            <array>
              <dict>
                <key>include</key>
                <string>#string_escape</string>
              </dict>
            </array>
          </dict>
          <dict>
            <key>captures</key>
            <dict>
              <key>1</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
              <key>3</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>comment</key>
            <string>this is faster than the next begin/end rule since sub-pattern will match till end-of-line and SQL files tend to have very long lines.</string>
            <key>match</key>
            <string>(")(?:[^"#]|\"|\')*(")</string>
            <key>name</key>
            <string>string.quoted.double.sql</string>
          </dict>
          <dict>
            <key>begin</key>
            <string>"</string>
            <key>beginCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
            </dict>
            <key>end</key>
            <string>"</string>
            <key>endCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>name</key>
            <string>string.quoted.double.sql</string>
            <key>patterns</key>
            <array>
              <dict>
                <key>include</key>
                <string>#string_interpolation</string>
              </dict>
            </array>
          </dict>
          <dict>
            <key>begin</key>
            <string>%\{</string>
            <key>beginCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
            </dict>
            <key>end</key>
            <string>\}</string>
            <key>endCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>name</key>
            <string>string.other.quoted.brackets.sql</string>
            <key>patterns</key>
            <array>
              <dict>
                <key>include</key>
                <string>#string_interpolation</string>
              </dict>
            </array>
          </dict>
        </array>
      </dict>
    </dict>
    <key>scopeName</key>
    <string>source.sql</string>
    <key>uuid</key>
    <string>A41BE23A-7EF9-11E5-857F-40167E632F0F</string>
  </dict>
</plist>